From ac038b66891264c510ecc068e7b86859d9b983eb Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Fri, 14 Jan 2022 15:58:45 +0100
Subject: [PATCH 1/3] STEAMOS: radv: min image count override for FH5

Otherwise in combination with the vblank time reservation in
gamescope the game could get stuck in low power states.
---
 src/util/00-radv-defaults.conf | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/util/00-radv-defaults.conf b/src/util/00-radv-defaults.conf
index 1cbb2e087c9..43488ada6bc 100644
--- a/src/util/00-radv-defaults.conf
+++ b/src/util/00-radv-defaults.conf
@@ -189,5 +189,9 @@ Application bugs worked around in this file:
         <application name="Rocket League" executable="RocketLeague">
             <option name="radv_zero_vram" value="true" />
         </application>
+
+        <application name="Forza Horizon 5" application_name_match="ForzaHorizon5.exe">
+            <option name="vk_x11_override_min_image_count" value="4" />
+        </application>
     </device>
 </driconf>
-- 
2.42.0


From 33b80c457f9c03d9991c06eac0b7f9f5d517ca77 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Mon, 21 Feb 2022 18:43:54 +0100
Subject: [PATCH 2/3] STEAMOS: Dynamic swapchain override for gamescope limiter

---
 src/loader/loader_dri3_helper.c | 42 +++++++++++++++++++++++++++++++--
 src/loader/loader_dri3_helper.h |  1 +
 src/loader/meson.build          |  2 +-
 3 files changed, 42 insertions(+), 3 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 2631a9e2fd5..dbf6db349c6 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -289,6 +289,30 @@ dri3_update_max_num_back(struct loader_dri3_drawable *draw)
    }
 }
 
+static unsigned
+gamescope_swapchain_override()
+{
+   const char *path = getenv("GAMESCOPE_LIMITER_FILE");
+   if (!path)
+      return 0;
+
+   static simple_mtx_t mtx = SIMPLE_MTX_INITIALIZER;
+   static int fd = -1;
+
+   simple_mtx_lock(&mtx);
+   if (fd < 0) {
+      fd = open(path, O_RDONLY);
+   }
+   simple_mtx_unlock(&mtx);
+
+   if (fd < 0)
+      return 0;
+
+   uint32_t override_value = 0;
+   pread(fd, &override_value, sizeof(override_value), 0);
+   return override_value;
+}
+
 void
 loader_dri3_set_swap_interval(struct loader_dri3_drawable *draw, int interval)
 {
@@ -303,10 +327,12 @@ loader_dri3_set_swap_interval(struct loader_dri3_drawable *draw, int interval)
     * PS. changing from value A to B and A < B won't cause swap out of order but
     * may still gets wrong target_msc value at the beginning.
     */
-   if (draw->swap_interval != interval)
+   if (draw->orig_swap_interval != interval)
       loader_dri3_swapbuffer_barrier(draw);
 
-   draw->swap_interval = interval;
+   draw->orig_swap_interval = interval;
+   if (gamescope_swapchain_override() != 1)
+      draw->swap_interval = interval;
 }
 
 static void
@@ -438,6 +464,12 @@ loader_dri3_drawable_init(xcb_connection_t *conn,
    draw->swap_interval = dri_get_initial_swap_interval(draw->dri_screen_render_gpu,
                                                        draw->ext->config);
 
+   draw->orig_swap_interval = draw->swap_interval;
+
+   unsigned gamescope_override = gamescope_swapchain_override();
+   if (gamescope_override == 1)
+      draw->swap_interval = 1;
+
    dri3_update_max_num_back(draw);
 
    /* Create a new drawable */
@@ -1085,6 +1117,12 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
    if (draw->type == LOADER_DRI3_DRAWABLE_WINDOW) {
       dri3_fence_reset(draw->conn, back);
 
+      unsigned gamescope_override = gamescope_swapchain_override();
+      if (gamescope_override == 1)
+         draw->swap_interval = 1;
+      else
+         draw->swap_interval = draw->orig_swap_interval;
+
       /* Compute when we want the frame shown by taking the last known
        * successful MSC and adding in a swap interval for each outstanding swap
        * request. target_msc=divisor=remainder=0 means "Use glXSwapBuffers()
diff --git a/src/loader/loader_dri3_helper.h b/src/loader/loader_dri3_helper.h
index cc2362dd599..fe73b3f329c 100644
--- a/src/loader/loader_dri3_helper.h
+++ b/src/loader/loader_dri3_helper.h
@@ -178,6 +178,7 @@ struct loader_dri3_drawable {
    bool block_on_depleted_buffers;
    bool queries_buffer_age;
    int swap_interval;
+   int orig_swap_interval;
 
    struct loader_dri3_extensions *ext;
    const struct loader_dri3_vtable *vtable;
diff --git a/src/loader/meson.build b/src/loader/meson.build
index 35f9991ba2f..154cf809a69 100644
--- a/src/loader/meson.build
+++ b/src/loader/meson.build
@@ -29,7 +29,7 @@ if with_platform_x11 and with_dri3
     dependencies : [
       idep_mesautil,
       dep_libdrm, dep_xcb_dri3, dep_xcb_present, dep_xcb_sync, dep_xshmfence,
-      dep_xcb_xfixes,
+      dep_xcb_xfixes, dep_xcb_xrandr, idep_mesautil
     ],
     build_by_default : false,
   )
-- 
2.42.0


From ff2a2a0e20a0cd4507897e363a5abdf273d6d0bd Mon Sep 17 00:00:00 2001
From: Friedrich Vock <friedrich.vock@gmx.de>
Date: Fri, 1 Dec 2023 15:18:44 +0100
Subject: [PATCH 3/3] radv: Enable compute dispatch tunneling

Compute tunneling can considerably lower the latency of high-priority
compute work. Enabling it is beneficial in cases where high-priority
work is dispatched while the GPU is already busy with other work (e.g.
rendering on GFX). This is the case in VR compositors that dispatch
latency-sensitive compositing work to ACE while GFX is busy rendering
the next frame.
---
 src/amd/vulkan/radv_device.c   | 7 +++++++
 src/amd/vulkan/si_cmd_buffer.c | 2 ++
 2 files changed, 9 insertions(+)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 247192d8a38..1b7117e08f7 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -969,6 +969,13 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
        */
       device->dispatch_initiator |= S_00B800_ORDER_MODE(1);
    }
+   if (device->physical_device->rad_info.gfx_level >= GFX10) {
+      /* Enable asynchronous compute tunneling. The KMD restricts this feature
+       * to high-priority compute queues, so setting the bit on any other queue
+       * is a no-op. PAL always sets this bit as well.
+       */
+      device->dispatch_initiator |= S_00B800_TUNNEL_ENABLE(1);
+   }
 
    /* Disable partial preemption for task shaders.
     * The kernel may not support preemption, but PAL always sets this bit,
diff --git a/src/amd/vulkan/si_cmd_buffer.c b/src/amd/vulkan/si_cmd_buffer.c
index 86a3c4c4571..eaa88b426d1 100644
--- a/src/amd/vulkan/si_cmd_buffer.c
+++ b/src/amd/vulkan/si_cmd_buffer.c
@@ -113,6 +113,8 @@ si_emit_compute(struct radv_device *device, struct radeon_cmdbuf *cs)
       radeon_emit(cs, 0); /* R_00B894_COMPUTE_USER_ACCUM_1 */
       radeon_emit(cs, 0); /* R_00B898_COMPUTE_USER_ACCUM_2 */
       radeon_emit(cs, 0); /* R_00B89C_COMPUTE_USER_ACCUM_3 */
+
+      radeon_set_sh_reg(cs, R_00B9F4_COMPUTE_DISPATCH_TUNNEL, 0);
    }
 
    /* This register has been moved to R_00CD20_COMPUTE_MAX_WAVE_ID
-- 
2.42.0

